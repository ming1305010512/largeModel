[TOC]



## 一句话先给你**标准定义**

> **“共现（co-occurrence）”指的是：
>  两个 Concept 在**同一个上下文单元**中同时出现过。**

⚠️ 重点：

- **不是**某一个 Concept 自己出现了多少次
- **而是**两个 Concept “一起出现”的事实 / 次数

------

## 1、放到你现在的业务里，“上下文单元”是什么？

在你的模型里：

```
Paper（试卷） → Question（试题） → Concept（知识点）
```

你当前定义的是：

> **“同一张试卷”是一个上下文单元**

所以：

> **共现 = 两个 Concept 出现在同一张试卷中（不管是不是同一道题）**

------

## 2、 用一个非常具体的例子

### 一张试卷 P1：

| 题号 | 知识点 |
| ---- | ------ |
| Q1   | A、B   |
| Q2   | B      |
| Q3   | C      |

### 那么：

- A 出现了 **1 次**
- B 出现了 **2 次**
- C 出现了 **1 次**

但 **共现** 看的是“成对关系”👇

| Concept1 | Concept2 | 是否共现     |
| -------- | -------- | ------------ |
| A & B    | ✔        | 因为同一试卷 |
| A & C    | ✔        | 同一试卷     |
| B & C    | ✔        | 同一试卷     |
| A & A    | ❌        | 排除自己     |
| B & B    | ❌        | 排除自己     |

👉 **即使 A 和 C 从未在同一道题中出现，也算共现**

------

## 3、那你刚刚问的这个问题，非常关键👇

> ❓“是不是 Concept 在试卷题目上出现的次数？”

### 答案是：**不是直接等于**

- Concept 自己出现多少次 → **出现频次（frequency）**
- 两个 Concept 一起出现多少次 → **共现次数（co-occurrence count）**

它们是两个**完全不同的统计维度**。

------

## 4、 那“共现次数”到底怎么算？

取决于你怎么定义“上下文单元”。

### ① 以「试卷」为上下文（你现在默认的）

> **一张试卷里，同一对 Concept 最多记 1 次共现**

| 试卷 | 包含的知识点 |
| ---- | ------------ |
| P1   | A B C        |
| P2   | A B          |
| P3   | B C          |

那么：

- (A,B) 共现次数 = 2（P1、P2）
- (A,C) 共现次数 = 1（P1）
- (B,C) 共现次数 = 2（P1、P3）

------

### ② 以「题目」为上下文（更细）

> **只有在同一道题里同时出现，才算 1 次共现**

如果：

| 题目 | 知识点 |
| ---- | ------ |
| Q1   | A、B   |
| Q2   | B、C   |
| Q3   | A      |

那么：

- (A,B) = 1
- (B,C) = 1
- (A,C) = 0

👉 这时 “共现”比“同一试卷”要严格很多。

------

## 5、 你现在这条 RELATED 语句，用的是哪一种？

你之前讨论的版本，本质上是：

> **以“试卷”为上下文的共现关系**

```
(paper)<-[:BELONG]-(q)-[:HAVE]->(c)
```

它不关心是不是同一道题，只关心是不是同一张试卷。

------

## 6、RELATED 关系里，“共现”一般怎么用？

通常有 3 种用途：

### ✅ 用途 1：弱相关（知识点网络）

> “做过这张试卷的人，往往同时接触到这些知识点”

适合：

- 推荐
- 聚类
- 图算法（PageRank、社区发现）

------

### ✅ 用途 2：统计共现强度

在关系上加属性：

```
(c1)-[:RELATED {cooccur: 12}]->(c2)
```

表示：

> A 和 B 在 12 个上下文中同时出现过

------

### ✅ 用途 3：阈值过滤

只保留“强关系”：

> 只保留 cooccur ≥ 3 的 RELATED

可以极大减少图的噪声和规模。

## 7、示例1

```
MATCH (paper:Paper)<-[:BELONG]-(q:Question)-[:HAVE]->(c:Concept) WITH paper, collect(DISTINCT c) AS cs UNWIND cs AS c1 UNWIND cs AS c2 WITH c1, c2 WHERE c1 <> c2 AND c1.code < c2.code MERGE (c1)-[r:RELATED]->(c2) ON CREATE SET r.cooccur = 1 ON MATCH SET r.cooccur = r.cooccur + 1;
```

这段 Cypher 的含义是：

> **以“试卷 paper”为上下文：把同一张试卷里出现过的所有知识点两两配对；对每一对知识点建立 `RELATED` 关系，并在关系上维护一个 `cooccur` 计数：这对知识点每在一张试卷里同时出现一次，`cooccur` 就 +1。**

我按行解释，你就能完全看懂它在做什么。

------

### 1）找出“试卷 → 题目 → 知识点”的所有出现

```
MATCH (paper:Paper)<-[:BELONG]-(q:Question)-[:HAVE]->(c:Concept)
```

含义：

- 找所有试卷 `paper`
- 找该试卷下的题 `q`
- 找题目关联的知识点 `c`

此时是**多行数据**：同一张试卷会有很多行（每个题的每个知识点一行）。

------

### 2）把“同一张试卷的所有知识点”收集成一个列表 cs

```
WITH paper, collect(DISTINCT c) AS cs
```

含义：

- 以 `paper` 分组
- 把这张试卷出现过的知识点 `c` 去重后收集成列表 `cs`

例子：某张试卷涉及知识点 A、B、C
 那 `cs = [A, B, C]`

> 这里 `DISTINCT` 很重要：避免同一知识点因为多道题出现而重复进列表。

------

### 3）两层 UNWIND：把列表做“全配对（笛卡尔积）”

```
UNWIND cs AS c1
UNWIND cs AS c2
```

含义：
 把 `[A,B,C]` 配对成：

(A,A) (A,B) (A,C)
 (B,A) (B,B) (B,C)
 (C,A) (C,B) (C,C)

也就是把同卷知识点做“全组合”。

------

### 4）只保留节点对，不要 paper 了

```
WITH c1, c2
```

含义：
 把 `paper` 这个维度丢掉（重要！），接下来就开始在**全局范围**累计 `cooccur`。

> 如果不丢掉 paper，而是 `WITH paper, c1, c2`，那后面 `MERGE`/`SET` 的统计逻辑会不同（会在每张试卷上分别处理）。

------

### 5）过滤：去掉自环 + 去掉重复方向

```
WHERE c1 <> c2 AND c1.code < c2.code
```

- `c1 <> c2`：不要 A-A 这种自己连自己
- `c1.code < c2.code`：避免 A-B 和 B-A 都出现，只保留一个方向（假设 `code` 是唯一且可比较的）

所以最终只留下：
 (A,B)、(A,C)、(B,C)

------

### 6）MERGE 关系：不存在就创建，存在就复用

```
MERGE (c1)-[r:RELATED]->(c2)
```

含义：

- 如果 `c1 -> c2` 的 RELATED 关系不存在：创建，并把它绑定到变量 `r`
- 如果已经存在：拿到已有的关系放进 `r`

------

### 7）关系上的 cooccur 计数：创建时=1，匹配到就+1

```
ON CREATE SET r.cooccur = 1
ON MATCH  SET r.cooccur = r.cooccur + 1;
```

含义：

- 第一次见到这对知识点：`cooccur = 1`
- 以后每当又发现它们在某张试卷里同时出现：`cooccur += 1`

### 所以 `cooccur` 最终表示什么？

✅ **全局层面：这对知识点在多少张试卷中“同时出现过”（同卷共现次数）**

举例：

- (A,B) 在 P1、P5、P9 三张试卷都出现过
   → `A-[:RELATED {cooccur:3}]->B`

------

### 重要提醒：这条语句统计的是“按试卷共现次数”

因为你先 `WITH paper, collect(DISTINCT c)`，所以每张试卷对 (A,B) **最多贡献 1 次**，不会因为同一卷里题目很多就重复加很多次。

## 8、示例2

```
MATCH (paper:Paper)<-[:BELONG]-(q:Question)-[:HAVE]->(c:Concept) WITH paper, collect(DISTINCT c) AS cs UNWIND cs AS c1 UNWIND cs AS c2 WITH c1, c2 WHERE c1 <> c2 AND c1.code < c2.code WITH c1, c2, count(*) AS cooccur WHERE cooccur >= 3 MERGE (c1)-[r:RELATED]->(c2) SET r.cooccur = cooccur;解释一下count(*)和 SET r.cooccur = cooccur;
```

### 结论

### ✅ `count(*) AS cooccur` 在这里数的是：

> **同一对知识点 (c1, c2) 在多少张试卷里同时出现过**
>  也就是“**共现试卷数**”。

### ✅ `SET r.cooccur = cooccur` 的意思是：

> 把上面算出来的这个“共现次数”写到 `RELATED` 关系的属性 `cooccur` 上（覆盖写入）。

------

### 你这段代码中 `count(*)` 为什么能数“试卷数”？

关键在于你前面这句：

```
WITH paper, collect(DISTINCT c) AS cs
```

这一步做了两件大事：

1. **按 paper 分组**
2. **每张试卷只保留一次每个 concept（DISTINCT）**

所以在后面做配对时：

- **每张试卷对于某一对 (c1,c2) 最多产生 1 行**
- 不会因为同一张卷里题很多、A/B出现多次，就产生很多重复行

------

### 用一个具体例子，你一眼就懂 `count(*)`

假设有 4 张试卷：

- P1 的知识点：A,B,C
- P2 的知识点：A,B
- P3 的知识点：A,B,D
- P4 的知识点：A,C

执行到两层 `UNWIND` + 过滤后（`c1<>c2 and c1.code<c2.code`），会出现这样的“行”（你可以把它想成中间结果表）：

| paper | c1   | c2   |
| ----- | ---- | ---- |
| P1    | A    | B    |
| P1    | A    | C    |
| P1    | B    | C    |
| P2    | A    | B    |
| P3    | A    | B    |
| P3    | A    | D    |
| P3    | B    | D    |
| P4    | A    | C    |

注意看 (A,B) 出现了几行？

- P1 一行
- P2 一行
- P3 一行
   → 一共 **3 行**

这就是你后面这句的来源：

```
WITH c1, c2, count(*) AS cooccur
```

它会把上表按 (c1,c2) 分组，数每组有多少行：

| c1   | c2   | cooccur |
| ---- | ---- | ------- |
| A    | B    | 3       |
| A    | C    | 2       |
| B    | C    | 1       |
| A    | D    | 1       |
| B    | D    | 1       |

所以，**`count(\*)` 在这里 = 这对知识点共同出现的试卷数**。

------

### 那 `WHERE cooccur >= 3` 呢？

```
WHERE cooccur >= 3
```

就是只保留“强相关”的 pair。
 上面的例子里只剩：

- (A,B,3)

------

### 最后 `SET r.cooccur = cooccur;` 是什么意思？

```
MERGE (c1)-[r:RELATED]->(c2)
SET r.cooccur = cooccur;
```

分两步理解：

#### 1）`MERGE`：保证关系存在

- 如果 A->B 的 RELATED 不存在：创建
- 如果存在：拿到现有关系

并把这条关系命名为变量 `r`

#### 2）`SET r.cooccur = cooccur`

把刚才算出来的 `cooccur`（比如 3）写到关系属性上：

最终关系变成：

```
(A)-[:RELATED {cooccur: 3}]->(B)
```

### 重要：这里是“覆盖写”

也就是每次跑这条语句，会把 `r.cooccur` **重新设置为这次统计出来的值**，而不是 +1 累加。

- 适合：你想“重算一遍真实值”
- 不适合：你想“增量更新”（每天新增试卷，只加新增部分）