## 1. 加载检查点

需加载模型状态字典、优化器状态字典、scaler状态字典、训练步数、全局最佳评分、容忍度计数器

```
def _load_checkpoint(self):
    # 判断如果检查点路径存在，就加载
    if self.checkpoint_path.exists():
        tqdm.write("发现检查点，加载状态继续训练...")
        # 获取检查点字典
        checkpoint = torch.load(self.checkpoint_path)
        # 对状态赋值
        self.model.load_state_dict(checkpoint['model_state_dict'])
        self.optimizer.load_state_dict(checkpoint['optimizer_state_dict'])
        self.scaler.load_state_dict(checkpoint['scaler_state_dict'])
        self.step = checkpoint['step']
        self.early_stop_best_score = checkpoint['early_stop_best_score']
        self.early_stop_counter = checkpoint['early_stop_counter']
    else:
        tqdm.write("没有检测到检查点，从头开始训练...")
```

## 2. 获取一批训练集，进行训练

```
# 一步训练（一次迭代）
def _train_one_step(self,inputs):
    # print(inputs)
    inputs = {k: v.to(self.device) for k, v in inputs.items()}
    # 前向传播，增加autocast上下文
    with torch.autocast(
        device_type=self.device.type,
        dtype = torch.float16,
        enabled = self.config.use_amp,
    ):
        outputs = self.model(**inputs)
        loss = outputs.get("loss")
    # 反向传播，增加GradScaler操作
    self.scaler.scale(loss).backward()
    self.scaler.step(self.optimizer)
    self.scaler.update()
    self.optimizer.zero_grad()
    return loss.item()
```

## 3. 达到一定步数记录loss，验证得到验证指标，判断是否早停，并保存最佳模型

```
# 如果达到了save_steps,就记录损失，判断是否保存模型
if self.step % self.config.save_steps == 0:
    # 记录loss
    tqdm.write(f'[Epoch:{epoch+1}] | Loss: {this_loss:.4f} | Step:{self.step}')
    self.writer.add_scalar('loss', this_loss, self.step)

    # 验证，得到验证指标
    metrics = self.evaluate()
    metrics_str = '|'.join([f'{k}:{v}' for k, v in metrics.items()])
    tqdm.write(f'[Evaluate: {metrics_str}]')

    # 早停判断处理
    if self._should_stop(metrics):
        tqdm.write('早停')
        return

    # 保存检查点
    self._save_checkpoint()
self.step += 1  # 迭代次数加
```

### 早停判断

```
def _should_stop(self,metrics):
    # 提取配置项中定义的指标值
    metric = metrics[self.config.early_stop_metric]
    # 转换评分
    score = -metric if self.config.early_stop_metric == 'loss' else metric
    # 判断如果超过最佳得分，就保存
    if score > self.early_stop_best_score:
        self.early_stop_best_score = score
        self.early_stop_counter = 0  # 计数清零
        tqdm.write('保存最佳模型...')
        save_dir = Path(self.config.output_dir) /"best"
        save_dir.mkdir(parents=True, exist_ok=True)  # ✅ 关键：创建父目录
        torch.save(self.model.state_dict(),save_dir /"cls_model_best.pt")
        return False
    else:
        self.early_stop_counter += 1  # 计数加1
        # 如果达到上限，就早停
        if self.early_stop_counter >= self.config.early_stop_patience:
            return True
        else:
            return False
```

### 评估

```
@torch.no_grad()
    def evaluate(self):
        self.model.eval()
        total_loss = 0.0
        n_batches = 0

        all_true, all_pred = [], []

        dataloader = self.datasetor.get_dataloader("valid")
        label2id,id2label = self.datasetor.get_cat_label_map()

        for batch in tqdm(dataloader):
            batch = {k: v.to(self.device) for k, v in batch.items()}
            outputs = self.model(**batch)
            loss = outputs.get("loss")
            # [b,c]
            logits = outputs.get("logits")

            total_loss += loss.item()
            n_batches += 1

            preds = torch.argmax(logits, dim=-1)  # [B, L]

            # Convert to seqeval format
            preds = preds.detach()
            labels = batch["labels"].detach()
            all_pred.extend(preds)
            all_true.extend(labels)
        # 使用sklearn.metrics获取准确率和f1
        acc = accuracy_score(all_true, all_pred)
        f1 = f1_score(y_true=all_true, y_pred=all_pred, average='macro')
        target_names = [label for label in id2label.values()]
        # report = classification_report(y_true=labels, y_pred=preds, target_names=target_names,digits=4,zero_division=0)
        # 混合矩阵
        cm = confusion_matrix(y_true=all_true, y_pred=all_pred)

        avg_loss = total_loss / max(1, n_batches)

        return {"loss": avg_loss, "accuracy": acc,  "f1": f1, "cm": cm}
```