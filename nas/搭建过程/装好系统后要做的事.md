[TOC]



## 1. 更新系统

```
sudo apt update
sudo apt upgrade -y
```

## 2. 挂载 2TB SSD

### 看硬盘

```
lsblk
```

###  给 2TB 盘分区 + 格式化（如果是新盘）

⚠️ **确认你选对盘再敲**

```
sudo fdisk /dev/nvme1n1
```

接下来按下来面

```
Command (m for help):
```

#### ✅ 第 1 步：查看当前分区表类型（可选）

```
p
```

如果看到 `Disklabel type: dos`
 说明现在是 **MBR（我们不想要）**

------

#### ✅ 第 2 步：切换成 GPT（关键一步）

在 `Command (m for help):` 下输入：

```
g
```

然后回车。

你会看到类似提示：

```
Created a new GPT disklabel
```

👉 **这一步 = 把分区表切换为 GPT（但还没写盘）**

------

#### ✅ 第 3 步：确认现在是 GPT（强烈建议）

```
p
```

你应该能看到：

```
Disklabel type: gpt
```

#### 4. 新建分区

```
n
```

然后一路回车：

- 分区号：回车（默认 1）
- 起始扇区：回车
- 结束扇区：回车（用满 2T）

你现在得到的是：

```
/dev/nvme1n1p1
```

------

#### 5. 把这个分区标记为 **LVM 类型**（关键）

在 `fdisk` 里输入：

```
t
```

然后：

- 分区号：`1`
- 类型：输入L查看列表，找到Linux LVM（为30）

```
30
```

👉 这代表：**Linux LVM**

#### 6. 写入磁盘

输入w



## 3、开始 LVM（这是 NAS 的核心）

下面每一步我都标注「你在干嘛」。

------

## 1️⃣ 创建物理卷（PV）

```
sudo pvcreate /dev/nvme1n1p1
```

意义：
 👉 **告诉 LVM：这是一块可用的物理存储**

验证一下（可选）：

```
pvs
```

------

## 2️⃣ 创建卷组（VG）

我们给它起个清晰的名字，比如：`data-vg`

```
sudo vgcreate data-vg /dev/nvme1n1p1
```

意义：
 👉 **把 2T 盘纳入一个“存储池”**

查看：

```
vgs
```

------

## 3️⃣ 创建逻辑卷（LV）

先创建一个 **占满整个盘的逻辑卷**（以后也能拆）

```
sudo lvcreate -n data-lv -l 100%FREE data-vg
```

你现在有了：

```
/dev/data-vg/data-lv
```

查看：

```
lvs
```

------

## 4. 格式化为 ext4（这一步才是真正“用起来”）

```
sudo mkfs.ext4 /dev/data-vg/data-lv
```

👉 现在才是 **真正格式化**，前面都只是结构准备。

------

## 5. 挂载成你的 NAS 数据目录

## 1️⃣ 创建挂载点（推荐）

```
sudo mkdir -p /data
```

## 2️⃣ 手动挂载测试

```
sudo mount /dev/data-vg/data-lv /data
```

验证：

```
df -h
```

你应该能看到：

```
/dev/mapper/data--vg-data--lv   ~1.8T   /data
```

------

## 6. 设置开机自动挂载（很重要）

## 1️⃣ 获取 UUID

```
sudo blkid /dev/data-vg/data-lv
```

会得到类似：

```
UUID="xxxx-xxxx-xxxx"
```

## 2️⃣ 编辑 fstab

```
sudo nano /etc/fstab
```

在最后一行加：

```
UUID=xxxx-xxxx-xxxx  /data  ext4  defaults  0  2
```

保存退出。

## 3️⃣ 测试是否写对（不会真重启）

```
sudo mount -a
```

如果**没报错**，说明配置正确 ✅



## 7. 设置用户、权限

```
#!/usr/bin/env bash
set -euo pipefail

############################################
# 0) 可改变量（只改这里）
############################################
VAULT_ROOT="/data/vault"
KB_ROOT="${VAULT_ROOT}/knowledge"

# 你现在登录的 Linux 用户名一般就是你的；也可手动写死，例如 "longming"
USER_LONGMING="${USER_LONGMING:-$(id -un)}"

# 你老婆在这台机器上的 Linux 用户名（建议建一个，比如 wife / chuying 等）
# 如果你还没创建她的 Linux 用户，也可以先把它改成跟你一样，后面再改回来跑一次脚本即可
USER_WIFE="${USER_WIFE:-chuyin}"

# 共享组名：两个人都加入这个组，方便共享目录读写
VAULT_GROUP="vault"

# 目录权限：770 = 组内可读写执行，组外无权限（更安全）
DIR_MODE="2770"     # 2xxx 表示 setgid：新文件自动继承组
FILE_MODE="0660"

############################################
# 1) 前置检查
############################################
if [[ $EUID -ne 0 ]]; then
  echo "请用 root 执行（或 sudo）：sudo bash $0"
  exit 1
fi

echo "==> VAULT_ROOT: ${VAULT_ROOT}"
echo "==> KB_ROOT:    ${KB_ROOT}"
echo "==> longming user: ${USER_LONGMING}"
echo "==> wife user:     ${USER_WIFE}"
echo "==> group:         ${VAULT_GROUP}"
echo

############################################
# 2) 创建组 & 加入用户
############################################
if ! getent group "${VAULT_GROUP}" >/dev/null; then
  echo "==> 创建组 ${VAULT_GROUP}"
  groupadd "${VAULT_GROUP}"
fi

# 用户存在才加入组（避免报错）
for u in "${USER_LONGMING}" "${USER_WIFE}"; do
  if id "${u}" >/dev/null 2>&1; then
    echo "==> 把用户 ${u} 加入组 ${VAULT_GROUP}"
    usermod -aG "${VAULT_GROUP}" "${u}"
  else
    echo "!! 提醒：用户 ${u} 不存在，跳过加入组。你可以先创建：sudo adduser ${u}"
  fi
done

############################################
# 3) 建目录结构
############################################
echo "==> 创建目录结构"
mkdir -p "${KB_ROOT}"/{_shared,_index,_meta}
mkdir -p "${KB_ROOT}/_shared"/{00_sources,01_notes,02_topics,03_outputs,99_assets}
mkdir -p "${KB_ROOT}/_index"/{embeddings,metadata,snapshots}

mkdir -p "${KB_ROOT}/${USER_LONGMING}"/{00_sources,01_notes,02_topics,03_outputs,projects,99_assets,inbox}
mkdir -p "${KB_ROOT}/${USER_WIFE}"/{00_sources,01_notes,02_topics,03_outputs,cases,99_assets,inbox}

############################################
# 4) 所有目录统一归属到 vault 组 + setgid
############################################
echo "==> 设置组归属与目录权限（setgid）"
mkdir -p "${VAULT_ROOT}"
chgrp -R "${VAULT_GROUP}" "${VAULT_ROOT}"
chmod 2770 "${VAULT_ROOT}" || true
find "${VAULT_ROOT}" -type d -exec chmod "${DIR_MODE}" {} \;

############################################
# 5) 设置“所有者”策略
#    - 共享区归 longming: vault
#    - 个人区归各自用户: vault（用户不存在就归 root:vault）
############################################
echo "==> 设置目录所有者"
if id "${USER_LONGMING}" >/dev/null 2>&1; then
  chown -R "${USER_LONGMING}:${VAULT_GROUP}" "${KB_ROOT}/_shared" "${KB_ROOT}/_index" "${KB_ROOT}/_meta"
  chown -R "${USER_LONGMING}:${VAULT_GROUP}" "${KB_ROOT}/${USER_LONGMING}"
else
  chown -R root:${VAULT_GROUP} "${KB_ROOT}/_shared" "${KB_ROOT}/_index" "${KB_ROOT}/_meta" "${KB_ROOT}/${USER_LONGMING}"
fi

if id "${USER_WIFE}" >/dev/null 2>&1; then
  chown -R "${USER_WIFE}:${VAULT_GROUP}" "${KB_ROOT}/${USER_WIFE}"
else
  chown -R root:${VAULT_GROUP} "${KB_ROOT}/${USER_WIFE}"
fi

############################################
# 6) （可选但强烈推荐）ACL：保证两人都能写 shared，且默认继承
############################################
echo "==> 配置 ACL（如果系统支持 setfacl）"
if command -v setfacl >/dev/null 2>&1; then
  # 共享区：组 vault 拥有 rwx，并设置默认继承
  setfacl -R -m g:"${VAULT_GROUP}":rwx "${KB_ROOT}/_shared"
  setfacl -R -d -m g:"${VAULT_GROUP}":rwx "${KB_ROOT}/_shared"

  # 各自个人区：owner full，组 vault 也可 rwx（方便互相临时协作）
  setfacl -R -m g:"${VAULT_GROUP}":rwx "${KB_ROOT}/${USER_LONGMING}" || true
  setfacl -R -d -m g:"${VAULT_GROUP}":rwx "${KB_ROOT}/${USER_LONGMING}" || true

  setfacl -R -m g:"${VAULT_GROUP}":rwx "${KB_ROOT}/${USER_WIFE}" || true
  setfacl -R -d -m g:"${VAULT_GROUP}":rwx "${KB_ROOT}/${USER_WIFE}" || true
else
  echo "!! 未检测到 setfacl（ACL）。如需更细权限：sudo apt-get install -y acl"
fi

############################################
# 7) README：写入目录说明
############################################
README_PATH="${KB_ROOT}/_meta/README.md"
echo "==> 写入 README: ${README_PATH}"

cat > "${README_PATH}" <<'EOF'
# 家庭知识库目录说明（v1）

> 目标：把“文件资产、可读笔记、主题沉淀、输出成果、AI索引”分层，长期可维护、可检索、可协作。

## 根目录
- `knowledge/_shared/`：夫妻共同的长期知识资产（最重要）
- `knowledge/<user>/`：个人工作台（各自沉淀）
- `knowledge/_index/`：AI/搜索索引（可重建，不算知识本体）
- `knowledge/_meta/`：规范、说明、约定（README、命名规则等）

---

## 分层含义（00→03 是“信息到价值”的流水线）
- `00_sources/`：原始资料库（PDF、网页导出、截图、原文、书籍、课程材料），尽量不改动
- `01_notes/`：可读笔记（结构化理解，能复习）
- `02_topics/`：主题提炼（按主题/疾病/技术点沉淀的“知识条目”）
- `03_outputs/`：输出成果（文章、方案、总结、PPT、分享稿、对外可复用）
- `99_assets/`：图片/表格/附件（给 notes/topics/outputs 引用）

---

## 使用约定（建议）
1. **收集先丢 inbox，再归档**
   - 临时资料先放 `inbox/`，每周/每月整理一次再移动到 00/01/02/03
2. **原始资料尽量只进 00_sources**
   - 避免多个地方重复保存同一 PDF
3. **`_index` 只放索引产物**
   - embeddings / metadata / snapshots，可删可重建
4. **共享区只放“共同认可的高质量内容”**
   - `_shared` 越干净越值钱

---

## 目录结构示例（概览）
- `_shared/00_sources` 夫妻共同资料原文
- `_shared/01_notes`   夫妻共同可读笔记
- `_shared/02_topics`  共同主题沉淀
- `_shared/03_outputs` 共同输出成果
- `_index/`            AI索引（向量库、ES索引、快照等）
EOF

# 将 README 也纳入组权限
chgrp "${VAULT_GROUP}" "${README_PATH}" || true
chmod 0660 "${README_PATH}" || true

############################################
# 8) 输出结果与提醒
############################################
echo
echo "✅ 完成！目录已创建并设置权限："
echo "   ${KB_ROOT}"
echo
echo "下一步提醒："
echo "1) 如果你刚把用户加入了 vault 组，需要重新登录/重启 shell 生效：newgrp ${VAULT_GROUP} 或重新 SSH 登录"
echo "2) 检查权限：ls -ld ${VAULT_ROOT} ${KB_ROOT} ${KB_ROOT}/_shared"
echo "3) 如要给老婆建 Linux 用户：sudo adduser ${USER_WIFE}"
echo

```

