[TOC]



# 1. zip函数

# 2. PIL模块属于哪一个

# 3. \_\_all\_\_有什么作用

在 Python 中，`__all__` 是一个模块级的“导出控制变量”，用于显式声明：

> **当使用 `from xxx import \*` 导入时，哪些名字可以被导入**。

## ✅ 一、基本语法

在模块（.py 文件）中定义：

```
__all__ = ['foo', 'bar']
```

表示：

```
from module import *
```

时，只会导入 `foo` 和 `bar`，其余的变量/函数/类不会导入。

## ✅ 二、详细说明

### 📌 背景

在 Python 中，如果你写：

```
from my_module import *
```

默认会把 **所有不以下划线开头的变量** 都导入到当前命名空间中。但这可能会：

- 导入太多不必要的内容
- 导入内部函数（不希望被外部使用的）
- 造成命名污染

于是，Python 提供了 `__all__` 来**手动控制**哪些名字可以被 `*` 导入。

### 📌 举个例子

```
# my_module.py

__all__ = ['func1']

def func1():
    print("func1")

def func2():
    print("func2")
```

如果你这样导入：

```
from my_module import *

func1()   # ✅ OK
func2()   # ❌ NameError: name 'func2' is not defined
```

------

## ✅ 三、注意事项

### ❗ 1. `import my_module` 不受影响

```
import my_module

my_module.func2()  # ✅ 依然可以访问
```

只有 `from my_module import *` 受 `__all__` 限制。

### ❗ 2. 没有定义 `__all__` 时

默认会导入所有 **非下划线开头的名称**：

```
def a(): ...
def _b(): ...

# 默认 from x import * 会导入 a，但不会导入 _b
```

------

### ❗ 3. `__all__` 只能限制 * 导入，不能限制显式导入

```
from my_module import func2  # ✅ 依然可以导入，即使 func2 不在 __all__ 中
```

## ✅ 五、小总结

| 内容                  | 说明                                                 |
| --------------------- | ---------------------------------------------------- |
| `__all__` 是一个 list | 里面是你允许 `from xxx import *` 导入的名字          |
| 默认行为              | 没有 `__all__` 时，`*` 会导入所有非 `_` 开头的标识符 |
| 只影响 `*` 导入       | 不影响普通的 `import` 或显式 `from ... import`       |